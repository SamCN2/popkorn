#! /bin/ksh

#usage: pkpolicy
#

PATH=/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin
PKCONF=${PKCONF:=/etc/popkorn.cf}
TMPFILE=/tmp/pkpolicy.$$.$RANDOM

. $PKCONF

#LOG=/var/log/popkorn/pkPolicy.log
#exec 2> $LOG
#squawk () {
#  print $1 1>&2
#}

finish() {
  rm -f $TMPFILE
  [[ X$1 == X ]] && exit 1	# if killed with a sig exit other than OK
  exit $1
}

trap finish 1 2 3 15

log() {
  logger -i -p mail.err $1
}

debug() {
  logger -i -p mail.debug $1
}

#
# As per Postfix docs [SMTPD_POLICY_README], the following messages come
#
#request=smtpd_access_policy
#protocol_state=RCPT
#protocol_name=SMTP
#helo_name=some.domain.tld
#queue_id=8045F2AB23
#sender=foo@bar.tld
#recipient=bar@foo.tld
#recipient_count=0
#client_address=1.2.3.4
#client_name=another.domain.tld
#reverse_client_name=another.domain.tld
#instance=123.456.7
#Postfix version 2.2 and later:
#sasl_method=plain
#sasl_username=you
#sasl_sender=
#size=12345
#ccert_subject=solaris9.porcupine.org
#ccert_issuer=Wietse+20Venema
#ccert_fingerprint=C2:9D:F4:87:71:73:73:D9:18:E7:C2:F3:C1:DA:6E:04
#Postfix version 2.3 and later:
#encryption_protocol=TLSv1/SSLv3
#encryption_cipher=DHE-RSA-AES256-SHA
#encryption_keysize=256
#etrn_domain=
#[empty line]

#We care about the following:
#
#       request         = smtpd_access_policy
#       protocol_state  = RCPT
#       protocol_name   = SMTP
#       recipient       = address
#
#We may in the future care about:
#
#       sasl_*          To determine whether message needs additional checks.
#                       That is, do known senders get free or reduce priced rides?
#
#       cert_*
#       encryption_*    Do we care whether the message came in well?
#                       Can we forego effort if sender dien't care?
#
function pkLookupUser {

  true
  TRUE=$?
  false
  FALSE=$?

#  nargs=${@#}
#  (( nargs == 1 )) || return $FALSE
#  [[ $1 == "" ]] && return $FALSE

  Recipient=$1

  Domain=${Recipient#*@}
  User=${Recipient%@*}
  RecipientID=${User%%[+-]*}
  
  domain=$BASEDIR/domain/$Domain

  alias=$domain/aliases/$RecipientID/_list
  forwdomain=$domain/_forwdomain
  aliases=$domain/aliases/$User/_list
  userdb=$domain/userdb

  #
  # Check for domain dir
  #
  [[ -d $domain ]] || return $FALSE
  
  #
  # Check for aliases or forwdomain files
  # Is OK if we forward the whole domain or have an alias
  # This implys a deferred check, by us or elseone     
  #
   
  [[ -f $alias ]] && return $TRUE
  [[ -f $forwdomain ]] && return $TRUE

  # OK now check for userid in userdb
  [[ -e $userdb ]] && egrep -i -s "^(${RecipientID}:|[^:]+:[^:]*:--default recipient--\$)" $userdb && return $TRUE
    
  # Else 
  return $FALSE
}

#
# set IFS to be space, tab, cr and newline.
# TCP connections don't have the same line discipline
# as terminal, and it's too much to push a stream
# or open a pty just to get this
#

printf " \r\t\n" | read ifs
IFS=$ifs

#
# The logic is split into getreq and preocreq because there is too much 
# prepration in procreq to allow getreq to be clean and understandable
#
# We do not do getreq | procrec because we need to hang around for the 
# next req.  This means that someone mush pay attention to EOF.  getreq
# is the logical choice.  However, we must not exit before processing the
# last request.  That request may well end with EOF.  So, we don't fall
# off the end of the getreq loop prior to calling procreq one last time.
# So, we end the whole production with a while ... do getreq | procreq done.

function procreq {

#
# clear vars to check later for complete request
# 
  request=""
  protocol_state=""
  protocol_name=""
  sender=""
  recipient=""

#
# Assume failure
#

  result=reject

#
# Only accept request input for which we understand what to do
#       Many current (and future) things will cause a rejection
# 		Any one of which is sufficient to reject, so short circuit
#		rejections, while continuing for local success
#
#		If we get to the end of the list, and status is still OK
#		then, and only then return accept.
#
#       And last, but not least, since we eval the var=val line into
#       the environment, ensure we know *exactly* what variables we set.
#


  while read line
  do
    [[ $line == request=* ]]        && eval $line
    [[ $line == protocol_state=* ]] && eval $line
    [[ $line == protocol_name=* ]]  && eval $line
    [[ $line == sender=* ]]         && eval $line
    [[ $line == recipient=* ]]      && eval $line
  done

  # For debugging with set -x  Allows to see expansion
  # but doesnt' do anything.  Take care for side effects.

  # Check all vars for complete request 
  debug "request $request from $sender to $recipient for $protocol_name in $protocol_state"

  if [[ $sender         == "" ]] ||
     [[ $protocol_state == "" ]] ||
     [[ $protocol_name  == "" ]] ||
     [[ $request        == "" ]] ||
     [[ $recipient      == "" ]] 
  then
    result=reject

  #
  # Here we'll eventually grelist, etc.
  # We'll keep a little db in /var/db/pkgrey/$sender/$client/$recipient/$tstamp
  # if this file exists, and $tstamp is > now + 5, then we'll greylist the delivery
  #
  # Greycheck
  #    if [[ -a $alias ]]
  #    if (( $(<$GREDB/client.sender.recipient.timestamp) < (now - 200))
  #    
  elif pkLookupUser $recipient
  then
    result=OK
  else
    result=reject
  fi
 

  print $result
} 

#while read line
#do
  # Skip empty lines

  until [[ $line != "" ]]
  do
    read line
  done

  # Now present those non empty lines to procreq
  # This could be done by collecting input into an array.
  # That would save a fork.  But we're not afraid of the fork.
  # The exec, yes, inspires a bit of trepidation.  But the
  # fork is our good friend.

  until [[ $line == "" ]]
  do
    print $line
    read line
  done | procreq | read action
  print action=$action
  print
#done

rm -f $TMPFILE
exit 0
