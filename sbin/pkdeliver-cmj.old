#! /bin/ksh

#usage: pkdeliver -r recipient	-s sender	-d domain

PATH=$PATH:/usr/local/bin:/usr/local/sbin
PKCONF=${PKCONF:=/etc/popkorn.cf}

. $PKCONF

exec 2>> $DELIVER_LOG


EX_USAGE=64              #/* command line usage error */
EX_DATAERR=65            #/* data format error */
EX_NOINPUT=66            #/* cannot open input */
EX_NOUSER=67             #/* addressee unknown */
EX_NOHOST=68             #/* host name unknown */
EX_UNAVAILABLE=69        #/* service unavailable */
EX_SOFTWARE=70           #/* internal software error */
EX_OSERR=71              #/* system error (e.g., can't fork) */
EX_OSFILE=72             #/* critical OS file missing */
EX_CANTCREAT=73          #/* can't create (user) output file */
EX_IOERR=74              #/* input/output error */
EX_TEMPFAIL=75           #/* temporary failure */
EX_PROTOCOL=76           #/* remote error in protocol */
EX_NOPERM=77             #/* permission denied */
EX_CONFIG=78             #/* configuration error */

ProgName=${0##*/}

squawk () {
#  logger -i -p mail.err $1
  print ${ProgName}: $(date +%Y:%m:%d:%H:%M:%S)  $1
}

finish() {
  rm -f $MessageData
  [[ X$1 = X ]] && exit 1	# if killed with a sig exit other than OK
  exit $1
}

trap finish 1 2 3 15

#BASEDIR=/home/popkorn
if ! cd $BASEDIR
then
  squawk "Cannot cd to $BASEDIR"
  finish $EX_TEMPFAIL
fi

usage() {
  print usage: $ProgName -r recipient -s sender -d domain
}

if [[ ( X$1 != X-r ) || (X$3 != X-s) || (X$5 != X-d) ]]
then
  usage
  finish $EX_USAGE
fi

typeset -l Recipient=$2
Sender=$4
typeset -l Domain=$6

RecipientID=${Recipient%%[+-]*}

#First off, save the message data...
MessageData="$PWD/msgdata.$$.$RANDOM"
tee $MessageData |
sed 's/^[.]//' | wc -c | read MsgSize # ...and count its de-dot-stuffed size

if ! cd "domain/$Domain"
then
  squawk  "Delivery Domain $Domain not supported"
  finish  $EX_NOUSER
fi

if [[ -s _forwdomain ]]
then

  while read faddr
  do
   
    case $faddr in
    '')
      continue
      ;;
    *@*)
      /usr/sbin/sendmail -f "$Sender" "$faddr" < $MessageData
      ;;
    *)
      squawk  "Delivery Domain $Domain not supported to $faddr"
      ;;
    esac
  done < _forwdomain
  finish 0
fi

if [[ -f aliases/$Recipient/_list ]]
then
 
  while read faddr
  do

    case $faddr in
    '')
      continue
      ;;
    *@*)
      /usr/sbin/sendmail -f "$Sender" "$faddr" < $MessageData
      ;;
    *)
      /usr/sbin/sendmail -f "$Sender" "$faddr@$Domain" < $MessageData
      ;;
    esac
  done < aliases/$Recipient/_list
fi


DEFAULT_MARKER='--default recipient--'
if [[ -a userdb ]]
then
  if egrep -s "^${RecipientID}:" userdb
  then
	: user exists
  elif egrep -s ":$DEFAULT_MARKER"\$ userdb
  then
	# Tweeze out (first) default recipient
	Recipient=$(sed < userdb -e "/:$DEFAULT_MARKER"'$/{
				s/:.*//
				q
				}
				d')
  else
	squawk "Recipient $RecipientID not authorized"
	finish $EX_NOUSER
  fi
fi

#Recipient dir:= recipient+folder -> recipient/folder
RecipientMdir=${Recipient}
[[ $Recipient = *[+-]* ]] &&
RecipientMdir=${Recipient%%[+-]*}/${Recipient#*[+-]}

# Ensure that delivery directories are in-place.  Make them, ingoring errors.
# Squawk if we cannot cd into them, though.

UserDeliveryDir=folders/${RecipientMdir}

[[ ! -d $UserDeliveryDir ]] &&
  mkdir -p "$UserDeliveryDir" &&
  chmod 770 "$UserDeliveryDir"

if ! cd $UserDeliveryDir
then
	squawk "Cannot change to user delivery dir $UserDeliveryDir"
	finish $EX_CANTCREAT
fi

# By now, we are in the proper delivery dir.  There should be three dirs here:
# new, cur, and tmp
# messages are delivered into tmp, and then moved into new.
#
# There may also be two control files, _forward, and _notify
# _forward files contain one address per line, they get the entire message,
# If one of them matches the recipients addr, we deliver here as well.
#
# _notify files also contain one address per line but only get the $Sender
# sent to them.

# Get Subject: line
while read tag roline 
do
  [[ $tag = [Ss]ubj* ]] && Subj="$roline" && break
done < $MessageData


# Handle _forward

DELIVER_ME=YES
if [[ -f _forward ]]
then
DELIVER_ME=NO
  while read forwardaddr
  do
    faddr=$forwardaddr
    [[ $forwardaddr = $Recipient@$Domain ]] && faddr=+metoo+
    [[ $forwardaddr = $Recipient ]] && faddr=+metoo+
    
    case $faddr in
    '')
      continue
      ;;
    '+metoo+')
      DELIVER_ME=YES
      ;;
    *@*)
      /usr/sbin/sendmail "$faddr" < $MessageData
      ;;
    *)
      /usr/sbin/sendmail "$faddr@$Domain" < $MessageData
      ;;
    esac
  done < _forward
fi



# Handle _vacation
if [[ -f _vacation ]]
then
  [[ $Sender  != $Recipient@$Domain ]] &&
    mailx -s "$Recipient@$Domain is away from email Re: $Subj" "$Sender" < _vacation
fi

# Handle _notify
#  Fortunately we just got the subject:
if [[ -f _notify ]]
then
  while read notifyaddr
  do
    [[ $notifyaddr  != $Recipient@$Domain ]] &&
    {
      print -R  From:  $Sender
      print -R '  Re:' $Subj
    }|
    mailx -s "New mail Re: $Subj" "$notifyaddr"
  done < _notify
fi

if [[ $DELIVER_ME = YES ]] 
then
#Deliver message

  for i in new cur tmp
  do
    [[ -d $i ]] || mkdir $i
  done > /dev/null 2>&1
  
  # Make up a unique file name.  $( date +%Y:%m:%d:%T ).$$.$RANDOM
  
  MsgFileName=msg.$(date +%Y.%m.%d.%H.%M.%S).$$.${RANDOM},S=${MsgSize}
  
  #Save the message

  if ! mv $MessageData new/$MsgFileName
  then
  	squawk "Unable to move message into $( pwd )new"
	finish $EX_CANTCREAT
  fi
fi  

finish  0
 
