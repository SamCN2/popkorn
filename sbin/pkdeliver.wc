#! /bin/ksh

#usage: pkdeliver -r recipient	-s sender	-d domain

PATH=$PATH:/usr/local/bin:/usr/local/sbin
PKCONF=${PKCONF:=/etc/popkorn.cf}

. $PKCONF

exec 2>> $DELIVER_LOG

EX_USAGE=64              #/* command line usage error */
EX_DATAERR=65            #/* data format error */
EX_NOINPUT=66            #/* cannot open input */
EX_NOUSER=67             #/* addressee unknown */
EX_NOHOST=68             #/* host name unknown */
EX_UNAVAILABLE=69        #/* service unavailable */
EX_SOFTWARE=70           #/* internal software error */
EX_OSERR=71              #/* system error (e.g., can't fork) */
EX_OSFILE=72             #/* critical OS file missing */
EX_CANTCREAT=73          #/* can't create (user) output file */
EX_IOERR=74              #/* input/output error */
EX_TEMPFAIL=75           #/* temporary failure */
EX_PROTOCOL=76           #/* remote error in protocol */
EX_NOPERM=77             #/* permission denied */
EX_CONFIG=78             #/* configuration error */

ProgName=$0

squawk () {
#  logger -i -p mail.err $1
  print ${ProgName}: $(date +%Y:%m:%d:%H:%M:%S)  $1
}

finish() {
  rm -f $MessageData
  [[ X$1 == X ]] && exit 1	# if killed with a sig exit other than OK
  exit $1
}

trap finish 1 2 3 15

#BASEDIR=/home/popkorn
if ! cd $BASEDIR
then
  squawk "Cannot cd to $BASEDIR"
  finish $EX_TEMPFAIL
fi

usage() {
  print usage $0 -r recipient -s sender -d domain
}

if [[ ( X$1 != X-r ) || (X$3 != X-s) || (X$5 != X-d) ]]
then
  usage
  finish $EX_USAGE
fi

typeset -l Recipient=$2
Sender=$4
typeset -l Domain=$6

RecipientID=$( print $Recipient | sed -e s'%[+-].*$%%' )

#First off, save the message data 
MessageData="/tmp/msgdata.$$.$RANDOM"
tee $MessageData | wc -c | read MsgSize

if ! cd domain/$Domain
then
  squawk  "Delivery Domain $Domain not supported"
  finish  $EX_NOUSER
fi

if [[ -s _forwdomain ]]
then

  while read faddr
  do
   
    case $faddr in
    '')
      continue
      ;;
    *@*)
      /usr/sbin/sendmail -f $Sender $faddr < $MessageData
      ;;
    *)
      squawk  "Delivery Domain $Domain not supported to $faddr"
      ;;
    esac
  done < _forwdomain
  finish 0
fi

if [[ -f aliases/$Recipient/_list ]]
then
 
  while read faddr
  do

    case $faddr in
    '')
      continue
      ;;
    *@*)
      /usr/sbin/sendmail -f $Sender $faddr < $MessageData
      ;;
    *)
      /usr/sbin/sendmail -f $Sender $faddr@$Domain < $MessageData
      ;;
    esac
  done < aliases/$Recipient/_list
  [[ $metoo = yes ]] || finish 0	# Does this get executed ??? XXX
fi


if [[ -a userdb ]]
then
  if ! egrep -s "^${RecipientID}:" userdb
  then
	squawk "Recipient $RecipientID not authorized"
	finish $EX_NOUSER
  fi
fi

#Recipient dir:= recipient+folder -> recipient/folder
RecipientMdir=$( print $Recipient | sed -e s'%[+-]%/%' )

# Ensure that delivery directories are in-place.  Make them, ingoring errors.
# Squawk if we cannot cd into them, though.

UserDeliveryDir=folders/${RecipientMdir}

[[ ! -f $UserDeliveryDir ]] &&
  mkdir -p $UserDeliveryDir &&
  chmod 770 $UserDeliveryDir 

if ! cd $UserDeliveryDir
then
	squawk "Cannot change to user delivery dir $UserDeliveryDir"
	finish EX_CANTCREAT
fi

# By now, we are in the proper delivery dir.  There should be three dirs here:
# new, cur, and tmp
# messages are delivered into tmp, and then moved into new.
#
# There may also be two control files, _forward, and _notify
# _forward files contain one address per line, they get the entire message,
# If one of them matches the recipients addr, we deliver here as well.
#
# _notify files also contain one address per line but only get the $sender
# sent to them.

# Get Subject: line
while read tag roline 
do
  [[ $tag == Subj* ]] && Subj="$roline" && break
  [[ $tag == subj* ]] && Subj="$roline" && break
done < $MessageData


# Handle _forward

DELIVER_ME=YES
if [[ -f _forward ]]
then
DELIVER_ME=NO
  while read forwardaddr
  do
#    faddr=$(cleanup $forwardaddr)
    faddr=$forwardaddr
    [[ $forwardaddr = $recipient@$domain ]] && faddr=+metoo+
    [[ $forwardaddr = $recipient ]] && faddr=+metoo+
    
    case $faddr in
    '')
      continue
      ;;
    '+metoo+')
      DELIVER_ME=YES
      ;;
    *@*)
      /usr/sbin/sendmail $faddr < $MessageData
      ;;
    *)
      /usr/sbin/sendmail $faddr@$Domain < $MessageData
      ;;
    esac
  done < _forward
fi



# Handle _vacation
if [[ -f _vacation ]]
then
  [[ $Sender  != $recipient@$domain ]] &&
    mailx -s "$recipient@$domain is away from email Re: $tag " $sender < _vacation
fi

# Handle _notify
#  Fortunately we just got the subject:
if [[ -f _notify ]]
then
  while read notifyaddr
  do
  [[ $notifyaddr  != $recipient@$domain ]] &&
    print "From:" $sender "\n" "Re: $tag" | mailx -s "New mail Re: $Subj" $notifyaddr
  done < _notify
fi

if [[ "$DELIVER_ME" = "YES" ]] 
then
#Deliver message

  for i in new cur tmp
  do
    [[ -d $i ]] || mkdir $i
  done > /dev/null 2>&1
  
  # Make up a unique file name.  $( date +%Y:%m:%d:%T ).$$.$RANDOM
  
  MsgFileName=msg.$(date +%Y.%m.%d.%H.%M.%S).$$.${RANDOM}:S=${MsgSize}
  
  #Save the message
  
  cat $MessageData > tmp/$MsgFileName
  
  if ! mv tmp/$MsgFileName new/$MsgFileName
  then
  	squawk "Unable to move message into $( pwd )new"
	finish $EX_CANTCREAT
  fi
fi  

finish  0
 
